###############################################################################
Assembly Language Specification
###############################################################################

This file describes the assembly language used by gdcc-as. By necessity it also
describes the intermediary representation system of GDCC, as the assembler is a
direct interface to it.

===============================================================================
Declarations
===============================================================================

Syntax:
  assembly-unit:
    declaration(opt) assembly-unit(opt)

  declaration:
    new-line
    function-declaration
    glyph-declaration
    import-declaration
    macro-declaration
    object-declaration
    space-declaration
    strent-declaration

Semantics:
  An assembly file is a series of declarations.

===========================================================
Functions
===========================================================

Syntax:
  function-declaration:
    <Function> string function-argument-list(opt) new-line

  function-argument-list:
    function-argument function-argument-list(opt)

  function-argument:
    <alloc> = expression
    <block> new-line { statement-list(opt) }
    <ctype> = call-type-specifier
    <defin> = expression
    <label> = string
    <linka> = linkage-specifier
    <localArr> [ expression ] = expression
    <localArs> = expression
    <localReg> = expression
    <param> = expression
    <retrn> = expression
    <sflagClS> = expression
    <sflagNet> = expression
    <stype> = script-type-specifier
    <valueInt> = expression
    <valueStr> = string

  statement-list:
    statement statement-list(opt)

Semantics:
  Defines a function. This includes ACS scripts, which are distinguished by the
  call type.

-----------------------------------------------------------
alloc (boolean)
-----------------------------------------------------------

Semantics:
  If 1, then the function will be given a generated valueInt if needed.

-----------------------------------------------------------
block
-----------------------------------------------------------

Semantics:
  Sets the block of statements associated with the function.

-----------------------------------------------------------
ctype
-----------------------------------------------------------

Semantics:
  Sets the function's call type.

-----------------------------------------------------------
defin (boolean)
-----------------------------------------------------------

Semantics:
  If 1, then the function is considered defined. Otherwise, it is considered
  external and needing import.

-----------------------------------------------------------
label
-----------------------------------------------------------

Semantics:
  Sets the label for the function's entry point. The label will be used for the
  function's first statement and must not be explicitly defined.

-----------------------------------------------------------
linka
-----------------------------------------------------------

Semantics:
  Sets the function's linkage.

-----------------------------------------------------------
localArr
-----------------------------------------------------------

Semantics:
  Sets the number of words to allocate for a specified local array.

-----------------------------------------------------------
localArs
-----------------------------------------------------------

Semantics:
  Sets the number of words to allocate for addressable locals.

-----------------------------------------------------------
localReg
-----------------------------------------------------------

Semantics:
  Sets the number of words to allocate for register locals.

  This must include register locals that are also function arguments, but does
  not need to include function arguments that are not register locals.

-----------------------------------------------------------
param
-----------------------------------------------------------

Semantics:
  Sets the number of parameter words.

-----------------------------------------------------------
retrn
-----------------------------------------------------------

Semantics:
  Sets the number of return words.

-----------------------------------------------------------
sflagClS (boolean)
-----------------------------------------------------------

Semantics:
  Sets the "clientside" script flag.

-----------------------------------------------------------
sflagNet (boolean)
-----------------------------------------------------------

Semantics:
  Sets the "net" script flag.

-----------------------------------------------------------
stype
-----------------------------------------------------------

Semantics:
  Sets the script type of the function.

-----------------------------------------------------------
valueInt
-----------------------------------------------------------

Semantics:
  Sets the function's integer value. Usually the index or ACS script number.

-----------------------------------------------------------
valueStr
-----------------------------------------------------------

Semantics:
  Sets the function's string value. Only meaningful for ACS named scripts.

===========================================================
Glyphs
===========================================================

Syntax:
  glyph-declaration:
    <Glyph> string glyph-argument-list(opt) new-line

  glyph-argument-list:
    glyph-argument glyph-argument-list(opt)

  glyph-argument:
    <type> = type
    <value> = expression

-----------------------------------------------------------
type
-----------------------------------------------------------

Semantics:
  Sets the glyph's type.

-----------------------------------------------------------
value
-----------------------------------------------------------

Semantics:
  Sets the glyph's value. The type of the expression must match the glyph's type.

===========================================================
Imports
===========================================================

Syntax:
  import-declaration:
    <Import> string new-line

Semantics:
  Specifies a library to link with at load-time.

===========================================================
Macros
===========================================================

Syntax:
  macro-declaration:
    <Macro> identifier new-line(opt) { statement-list(opt) }

  identifier:
    non-digit
    identifier non-digit
    identifier digit

  non-digit: one of
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    _

  digit: one of
    0 1 2 3 4 5 6 7 8 9

Semantics:
  Defines a macro that can be used to insert a statement list into another
  statement list. Any arguments in the macro of type Cpy are replaced by the
  numbered argument to the macro invocation.

  Macros are not part of the Intermediary Representation and exist only during
  assembling. Thus, their names have no linkage.

===========================================================
Objects
===========================================================

Syntax:
  object-declaration:
    <Object> string object-argument-list(opt) new-line

  object-argument-list:
    object-argument object-argument-list(opt)

  object-argument:
    <alias> = expression
    <alloc> = expression
    <defin> = expression
    <initi> = expression
    <linka> = linkage-specifier
    <space> = address-specifier string
    <value> = expression
    <words> = expression

-----------------------------------------------------------
alias (boolean)
-----------------------------------------------------------

Semantics:
  If 1, then the object may share an address with an object or sub-object with
  equivalent initializer.

-----------------------------------------------------------
alloc
-----------------------------------------------------------

Semantics:
  If 1, then the object will be given a generated value if needed.

-----------------------------------------------------------
defin (boolean)
-----------------------------------------------------------

Semantics:
  If 1, then the object is considered defined. Otherwise, it is considered
  external and needing import.

-----------------------------------------------------------
initi
-----------------------------------------------------------

Semantics:
  Sets the initial state of the object.

-----------------------------------------------------------
linka
-----------------------------------------------------------

Semantics:
  Sets the object's linkage.

-----------------------------------------------------------
value
-----------------------------------------------------------

Semantics:
  Sets the objects's integer value. Usually the starting memory index.

-----------------------------------------------------------
words
-----------------------------------------------------------

Semantics:
  Sets the number of words needed for the object.

===========================================================
Spaces
===========================================================

Syntax:
  space-declaration:
    <Space> address-specifier string space-argument-list(opt) new-line

  space-argument-list:
    space-argument space-argument-list(opt)

  space-argument:
    <alloc> = expression
    <defin> = expression
    <linka> = linkage-specifier
    <value> = expression
    <words> = expression

Semantics:
  Defines an address space to contain objects.

-----------------------------------------------------------
alloc
-----------------------------------------------------------

Semantics:
  If 1, then the space will be given a generated value if needed.

-----------------------------------------------------------
defin
-----------------------------------------------------------

Semantics:
  If 1, then the space is considered defined. Otherwise, it is considered
  external and needing import.

-----------------------------------------------------------
linka
-----------------------------------------------------------

Semantics:
  Sets the space's linkage.

-----------------------------------------------------------
value
-----------------------------------------------------------

Semantics:
  Sets the space's integer value. Usually the index.

-----------------------------------------------------------
words
-----------------------------------------------------------

Semantics:
  Sets the number of words needed for the space.

===========================================================
String Entries
===========================================================

Syntax:
  strent-declaration:
    <StrEnt> string strent-argument-list(opt) new-line

  strent-argument-list:
    strent-argument strent-argument-list(opt)

  strent-argument:
    <alias> = expression
    <alloc> = expression
    <defin> = expression
    <valueInt> = expression
    <valueStr> = string

Semantics:
  Defines a target string table entry.

-----------------------------------------------------------
alias
-----------------------------------------------------------

Semantics:
  If 1, then the string entry may share an address with an equivalent string
  entry.

-----------------------------------------------------------
alloc
-----------------------------------------------------------

Semantics:
  If 1, then the string entry will be given a generated value if needed.

-----------------------------------------------------------
defin
-----------------------------------------------------------

Semantics:
  If 1, then the string entry is considered defined. Otherwise, it is
  considered external and needing import.

-----------------------------------------------------------
valueInt
-----------------------------------------------------------

Semantics:
  Sets the string entry's integer value.

-----------------------------------------------------------
valueStr
-----------------------------------------------------------

Semantics:
  Sets the string entry's string value.

===============================================================================
Statements
===============================================================================

Syntax:
  statement:
    statement-label-list(opt) statement-name expression argument-list(opt)
      new-line
    statement-label-list(opt) ! identifier argument-list(opt) new-line

  statement-label-list:
    string statement-label-list(opt)

  argument-list:
    , argument argument-list(opt)

Semantics:
  A statement is the IR's instruction. The expression immediately following the
  statement name is an integer representing the operation size. How each
  instruction uses the operation size is documented below.

  Statements starting with a ! are a macro invocation.

===========================================================
Statement Names
===========================================================

Syntax:
  statement-name:
    <Nop>
    <AddF_W>
    <AddI_W>
    <AddU_W>
    <AndU_W>
    <Call>
    <Casm>
    <CmpF_EQ_W>
    <CmpF_GE_W>
    <CmpF_GT_W>
    <CmpF_LE_W>
    <CmpF_LT_W>
    <CmpF_NE_W>
    <CmpI_EQ_W>
    <CmpI_GE_W>
    <CmpI_GT_W>
    <CmpI_LE_W>
    <CmpI_LT_W>
    <CmpI_NE_W>
    <CmpU_EQ_W>
    <CmpU_GE_W>
    <CmpU_GT_W>
    <CmpU_LE_W>
    <CmpU_LT_W>
    <CmpU_NE_W>
    <Cnat>
    <Copy_W>
    <Cscr_IA>
    <Cscr_IS>
    <Cscr_SA>
    <Cscr_SS>
    <Cspe>
    <DiXI_W>
    <DiXU_W>
    <DivF_W>
    <DivI_W>
    <DivX_W>
    <InvU_W>
    <Jcnd_Nil>
    <Jcnd_Tru>
    <Jump>
    <ModI_W>
    <Move_W>
    <MuXU_W>
    <MulF_W>
    <MulI_W>
    <MulX_W>
    <NegF_W>
    <NegI_W>
    <NotU_W>
    <OrIU_W>
    <OrXU_W>
    <Plsa>
    <Plsf>
    <Pltn>
    <Retn>
    <ShLF_W>
    <ShLU_W>
    <ShRF_W>
    <ShRI_W>
    <ShRU_W>
    <SubF_W>
    <SubI_W>
    <SubU_W>
    <Swap_W>

-----------------------------------------------------------
Nop
-----------------------------------------------------------

Arguments:
  Nop 0

Semantics:
  Does nothing.

-----------------------------------------------------------
AdXU_W (Expanding Add Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  AdXU_W N, destination[N+1] dst, source[N] lop, source[N] rop
  AdXU_W N, destination[N+1] dst, source[N] lop, source[N] rop, source[1] carry

Semantics:
  Adds rop to lop and stores the result with carry in dst.

  If carry provided, it is also added to lop.

-----------------------------------------------------------
AddF_W (Add Signed Float Word)
AddI_W (Add Signed Integer Word)
AddU_W (Add Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  AddF_W N, desintation[N] dst, source[N] lop, source[N] rop
  AddI_W N, desintation[N] dst, source[N] lop, source[N] rop
  AddU_W N, desintation[N] dst, source[N] lop, source[N] rop

Semantics:
  Adds rop to lop and stores the result in dst.

-----------------------------------------------------------
AndU_W (Bitwise And Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  AndU_W N, desination[N] dst, source[N] lop, source[N] rop

Semantics:
  Bitwise ands lop with rop and stores the result in dst.

-----------------------------------------------------------
Call
-----------------------------------------------------------

Arguments:
  Call ret, source[1] addr, ...

Semantics:
  Calls a function at addr which returns ret words. Each additional argument is
  a word to pass to the called function.

  This instruction is meant to map to the typical function dispatch method for
  the target.

-----------------------------------------------------------
Casm (Call Assembly)
-----------------------------------------------------------

Arguments:
  Casm ret, source[1] addr, ...

Semantics:
  Calls a function at addr which returns ret words. Each additional argument is
  a word to pass to the called function.

  This instruction is meant to map to functions implemented as an instruction.

  For ZDACS targets, all arguments must have Lit type. The addr is used as an
  instruction number and the other arguments are immediate operands.

-----------------------------------------------------------
CmpF_*_W (Compare Signed Float Word)
CmpI_*_W (Compare Signed Integer Word)
CmpU_*_W (Compare Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  CmpF_*_W N, destination[1] dst, source[N] lop, source[N] rop
  CmpI_*_W N, destination[1] dst, source[N] lop, source[N] rop
  CmpU_*_W N, destination[1] dst, source[N] lop, source[N] rop

Semantics:
  EQ, GE, GT, LE, LT, NE variants compare if lop is equal, greater or equal,
  greater, less or equal, less, or unequal to rop, respectively. If the
  comparison is true, 1 is stored in dst. Otherwise, 0 is stored.

-----------------------------------------------------------
Cnat (Call Native)
-----------------------------------------------------------

Arguments:
  Cnat ret, source[1] addr, ...

Semantics:
  Calls a function at addr which returns ret words. Each additional argument is
  a word to pass to the called function.

  This instruction is meant to map to the native/builtin function dispatch
  method for the target.

-----------------------------------------------------------
Copy_W (Copy Word)
-----------------------------------------------------------

Arguments:
  Copy_W N, destination[N] dst, source[N] src

Semantics:
  Copies a word from src to dst.

-----------------------------------------------------------
Cscr_IA (Call Script, Integer Asynchronous)
Cscr_IS (Call Script, Integer Synchronous)
Cscr_SA (Call Script, String Asynchronous)
Cscr_SS (Call Script, String Synchronous)
-----------------------------------------------------------

Arguments:
  Cscr_IA ret, source[1] addr, ...
  Cscr_IS ret, source[1] addr, duplicate[ret+1] data, ...
  Cscr_SA ret, source[1] addr, ...
  Cscr_SS ret, source[1] addr, duplicate[ret+1] data, ...

Semantics:
  Calls a function at addr which returns ret words. Each additional argument is
  a word to pass to the called function.

  This instruction is meant to map to the ZDACS script dispatch method and may
  not be meaningful for other targets.

  The data argument is used for return data and should have type Loc.

-----------------------------------------------------------
Cspe (Call Special)
-----------------------------------------------------------

Arguments:
  Cspe ret, source[1] addr, ...

Semantics:
  Calls a function at addr which returns ret words. Each additional argument is
  a word to pass to the called function.

  This instruction is meant to map to the ZDACS line special dispatch method
  and may not be meaningful for other targets.

-----------------------------------------------------------
DiXI_W (Expanding Divide Signed Integer Word)
DiXU_W (Expanding Divide Unsigned Integer Word)
-----------------------------------------------------------

Argument:
  DiXI_W N, destination[N*2] dst, source[N] lop, source[N] rop
  DiXU_W N, destination[N*2] dst, source[N] lop, source[N] rop

Semantics:
  Divides lop by rop and stores the quotient and remainder in dst.

-----------------------------------------------------------
DivF_W (Divide Signed Integer Word)
DivI_W (Divide Signed Integer Word)
DivU_W (Divide Unsigned Integer Word)
-----------------------------------------------------------

Argument:
  DivF_W N, destination[N] dst, source[N] lop, source[N] rop
  DivI_W N, destination[N] dst, source[N] lop, source[N] rop
  DivU_W N, destination[N] dst, source[N] lop, source[N] rop

Semantics:
  Divides lop by rop and stores the quotient in dst.

-----------------------------------------------------------
InvU_W (Bitwise Invert Unsigned Integer Word
-----------------------------------------------------------

Argument:
  InvU_W N, destination[N] dst, source[N] src

Semantics:
  Bitwise inverts src and stores the result in dst.

-----------------------------------------------------------
Jcnd_Nil (Conditional Jump, Nil)
Jcnd_Tru (Conditional Jump, True)
-----------------------------------------------------------

Arguments:
  Jcnd_Nil N, source[N] cnd, source[1] addr
  Jcnd_Tru N, source[N] cnd, source[1] addr

Semantics:
  Jcnd_Nil checks if cnd is zero.

  Jcnd_Tru checks if cnd is nonzero.

  If condition passes, branches execution to addr.

-----------------------------------------------------------
Jump
-----------------------------------------------------------

Arguments:
  Jump 0, source[1] addr

Semantics:
  Branches execution to addr.

-----------------------------------------------------------
ModI_W (Modulus Signed Integer Word)
ModU_W (Modulus Unsigned Integer Word)
-----------------------------------------------------------

Argument:
  ModI_W N, destination[N] dst, source[N] lop, source[N] rop
  ModU_W N, destination[N] dst, source[N] lop, source[N] rop

Semantics:
  Divides lop by rop and stores the remainder in dst.

-----------------------------------------------------------
Move_W (Move Word)
-----------------------------------------------------------

Arguments:
  Move_W N, destination[N] dst, source[N] src

Semantics:
  Moves a word from src to dst.

-----------------------------------------------------------
MuXU_W (Expanding Multiply Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  MuXU_W N, destination[N*2] dst, source[N] lop, source[N] rop

Semantics:
  Multiplies lop by rop and stores the full result in dst.

-----------------------------------------------------------
MulF_W (Multiply Signed Float Word)
MulI_W (Multiply Signed Integer Word)
MulU_W (Multiply Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  MulF_W N, destination[N] dst, source[N] lop, source[N] rop
  MulI_W N, destination[N] dst, source[N] lop, source[N] rop
  MulU_W N, destination[N] dst, source[N] lop, source[N] rop

Semantics:
  Multiplies lop by rop and stores the truncated result in dst.

-----------------------------------------------------------
NegF_W (Negate Signed Float Word)
NegI_W (Negate Signed Integer Word)
-----------------------------------------------------------

Arguments:
  NegF_W N, destination[N] dst, source[N] src
  NegI_W N, destination[N] dst, source[N] src

Semantics:
  Negates src and stores the result in dst.

-----------------------------------------------------------
NotU_W (Logical Invert Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  NotU_W N, destination[1] dst, source[N] src

Semantics:
  Logically inverts src and stores the result in dst.

-----------------------------------------------------------
OrIU_W (Bitwise Inclusive Or Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  OrIU_W N, destination[N] dst, source[N] lop, source[N] rop

Semantics:
  Bitwise inclusive ors lop with rop and stores the result in dst.

-----------------------------------------------------------
OrXU_W (Bitwise Exclusive Or Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  OrXU_W N, destination[N] dst, source[N] lop, source[N] rop

Semantics:
  Bitwise exclusive ors lop with rop and stores the result in dst.

-----------------------------------------------------------
Plsa (Pointer, Local Stack Allocate)
-----------------------------------------------------------

Arguments:
  Plsa 0, source[1] size

Semantics:
  Allocates the local stack.

-----------------------------------------------------------
Plsf (Pointer, Local Stack Free)
-----------------------------------------------------------

Arguments:
  Plsf 0

Semantics:
  Frees the local stack.

-----------------------------------------------------------
Pltn (Pointer, Local To Near)
-----------------------------------------------------------

Arguments:
  Pltn 0, destination[1] dst, source[1] src

Semantics:
  Converts from a Loc pointer in src to a LocArs pointer in dst.

-----------------------------------------------------------
Retn (Return)
-----------------------------------------------------------

Arguments:
  Retn 0
  Retn N, source[N] src

Semantics:
  Returns control to the caller with the data in src. If N is zero, no data is
  returned and src may be omitted.

-----------------------------------------------------------
ShLF_W (Shift Left Signed Float Word)
ShLU_W (Shift Left Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  ShLF_W N, destination[N] dst, source[N] lop, source[1] rop
  ShLU_W N, destination[N] dst, source[N] lop, source[1] rop

Semantics:
  Left-shifts lop by rop and stores the result in dst.

  For float ops, this adds to the exponent.

-----------------------------------------------------------
ShRF_W (Shift Right Signed Float Word)
ShRI_W (Shift Right Signed Integer Word)
ShRU_W (Shift Right Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  ShRF_W N, destination[N] dst, source[N] lop, source[1] rop
  ShRI_W N, destination[N] dst, source[N] lop, source[1] rop
  ShRU_W N, destination[N] dst, source[N] lop, source[1] rop

Semantics:
  Right-shifts lop by rop and stores the result in dst.

  For float ops, this subtracts from the exponent.

  For signed fixed-point ops, this may sign-extend.

-----------------------------------------------------------
SuXU_W (Expanding Subtract Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  SuXU_W N, destination[N+1] dst, source[N] lop, source[N] rop
  SuXU_W N, destination[N+1] dst, source[N] lop, source[N] rop, source[1] carry

Semantics:
  Subtracts rop from lop and stores the result with carry in dst.

  If carry provided, it is also added to lop.

-----------------------------------------------------------
SubF_W (Subtract Signed Float Word)
SubI_W (Subtract Signed Integer Word)
SubU_W (Subtract Unsigned Integer Word)
-----------------------------------------------------------

Arguments:
  SubF_W N, desintation[N] dst, source[N] lop, source[N] rop
  SubI_W N, desintation[N] dst, source[N] lop, source[N] rop
  SubU_W N, desintation[N] dst, source[N] lop, source[N] rop

Semantics:
  Subtracts rop from lop and stores the result in dst.

-----------------------------------------------------------
Swap_W (Swap Word)
-----------------------------------------------------------

Arguments:
  Swap_W N, duplicate[N] lop, duplicate[N] rop

Semantics:
  Swaps lop with rop.

===========================================================
Arguments
===========================================================

Syntax:
  argument:
    <Aut> ( argument argument-offset(opt) )
    <Cpy> ( expression(opt) )
    <Far> ( argument argument-offset(opt) )
    <GblArr> ( argument , argument argument-offset(opt) )
    <GblArs> ( argument argument-offset(opt) )
    <GblReg> ( argument argument-offset(opt) )
    <Gen> ( argument argument-offset(opt) )
    <Lit> ( expression argument-offset(opt) )
    <LocReg> ( argument argument-offset(opt) )
    <MapArr> ( argument , argument argument-offset(opt) )
    <MapArs> ( argument argument-offset(opt) )
    <MapReg> ( argument argument-offset(opt) )
    <Nul> ( )
    <Sta> ( argument argument-offset(opt) )
    <Stk> ( )
    <StrArr> ( argument , argument argument-offset(opt) )
    <StrArs> ( argument argument-offset(opt) )
    <Vaa> ( argument argument-offset(opt) )
    <WldArr> ( argument , argument argument-offset(opt) )
    <WldArs> ( argument argument-offset(opt) )
    <WldReg> ( argument argument-offset(opt) )

  argument-offset:
    , expression

===============================================================================
Expressions
===============================================================================

Syntax:
  expression:
    aggregate
    aggregate-string
    number
    string
    value
    <Add> ( expression , expression )
    <AddPtrRaw> ( expression , expression )
    <BitAnd> ( expression , expression )
    <BitOrI> ( expression , expression )
    <BitOrX> ( expression , expression )
    <CmpEQ> ( expression , expression )
    <CmpGE> ( expression , expression )
    <CmpGT> ( expression , expression )
    <CmpLE> ( expression , expression )
    <CmpLT> ( expression , expression )
    <CmpNE> ( expression , expression )
    <Cnd> ( expression , expression , expression )
    <Cst> ( type , expression )
    <Div> ( expression , expression )
    <Inv> ( expression )
    <LogAnd> ( expression , expression )
    <LogOrI> ( expression , expression )
    <LogOrX> ( expression , expression )
    <Mod> ( expression , expression )
    <Mul> ( expression , expression )
    <Neg> ( expression )
    <Not> ( expression )
    <ShL> ( expression , expression )
    <ShR> ( expression , expression )
    <Sub> ( expression , expression )
    -- expression
    ~ expression
    ! expression
    * expression expression
    / expression expression
    % expression expression
    + expression expression
    - expression expression
    << expression expression
    >> expression expression
    < expression expression
    > expression expression
    <= expression expression
    >= expression expression
    == expression expression
    != expression expression
    & expression expression
    ^ expression expression
    | expression expression
    && expression expression
    ^^ expression expression
    || expression expression
    ? expression expression expression

  type:
    type-Array
    type-Assoc
    type-Empty
    type-Fixed
    type-Float
    type-Funct
    type-Point
    type-StrEn
    type-Tuple
    type-Union

  type-Array:
    <Array> ( type , expression )

  type-Assoc:
    <Assoc> ( type-assoc-list(opt) )

  type-Empty:
    <Empty> ( )

  type-Fixed:
    <Fixed> ( expression , expression , expression , expression )

  type-Float:
    <Float> ( expression , expression , expression , expression )

  type-Funct:
    <Funct> ( call-type-specifier )

  type-Point:
    <Point> ( address-specifier string , expression , expression )

  type-StrEn:
    <StrEn> ( )

  type-Tuple:
    <Tuple> ( type-list(opt) )

  type-Union:
    <Union> ( type-list(opt) )

  type-assoc-list:
    type-assoc
    type-assoc , type-assoc-list

  type-assoc:
    type string expression

  type-list:
    type
    type , type-list

===========================================================
Aggregates
===========================================================

Syntax:
  aggregate:
    <Tuple> ( expression-list(opt) )
    { expression-list(opt) }
    [ expression-list(opt) ]

  expression-list:
    expression
    expression , expression-list

Semantics:
  Results in a multi-part value. Each sub-expression has its own type.

  In the first and second forms, expression evaluation is deferred. In the
  third form, expressions are evaluated immediately and cannot contain unbacked
  glyphs.

===========================================================
Aggregate Strings
===========================================================

Syntax:
  aggregate-string:
    <string> type-Fixed(opt) string

Semantics:
  Results in a multi-part value comprised of the characters in the string. The
  type of each element is determined by an explicit type or a target-dependent
  default.

===========================================================
Numbers
===========================================================

Syntax:
  number:
    decimal-number number-suffix(opt)
    hexadecimal-number number-suffix(opt)
    octal-number number-suffix(opt)

  decimal-number:
    decimal-base decimal-fractional(opt) decimal-exponent(opt)
    decimal-integral(opt) decimal-fractional decimal-exponent(opt)

  hexadecimal-number:
    hexadecimal-base hexadecimal-fractional(opt) hexadecimal-exponent(opt)

  octal-number:
    octal-base decimal-exponent(opt)

  number-suffix:
    _ number-suffix-f(opt) number-suffix-s(opt) decimal-integral
      decimal-fractional number-suffix-s(opt)

  number-suffix-f: one of
    <F> <f>

  number-suffix-s: one of
    <S> <s>

  decimal-base:
    decimal-prefix decimal-integral(opt)

  decimal-fractional:
    . decimal-integral(opt)

  decimal-exponent:
    <E> sign(opt) decimal-integral
    <e> sign(opt) decimal-integral
    hexadecimal-exponent

  decimal-integral:
    digit decimal-integral(opt)

  decimal-prefix: one of
    1 2 3 4 5 6 7 8 9

  hexadecimal-base:
    hexadecimal-prefix hexadecimal-integral(opt)

  hexadecimal-fractional:
    . hexadecimal-integral(opt)

  hexadecimal-exponent:
    <P> sign(opt) decimal-integral
    <p> sign(opt) decimal-integral

  hexadecimal-integral:
    hexadecimal-digit hexadecimal-integral(opt)

  hexadecimal-digit: one of
    0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

  octal-base:
    octal-prefix octal-integral(opt)

  octal-prefix:
    0

  octal-integral:
    octal-digit octal-integral(opt)

  octal-digit: one of
    0 1 2 3 4 5 6 7

  sign: one of
    + -

===========================================================
Strings
===========================================================

Syntax:
  string:
    " char-sequence(opt) "

  char-sequence:
    char char-sequence(opt)

  char:
    any character except double-quote, backslash, or new-line
    escape-sequence

  escape-sequence:
    hexadecimal-escape-sequence
    octal-escape-sequence
    simple-escape-sequence

  hexadecimal-escape-sequence:
    \x hexadecimal-digit
    hexadecimal-escape-sequence hexadecimal-digit

  octal-escape-sequence:
    \ octal-digit
    \ octal-digit octal-digit
    \ octal-digit octal-digit octal-digit

  simple-escape-sequence: one of
    \' \" \? \\ \a \b \f \n \r \t \v

Semantics:
  As an expression, a string indicates a glyph to be resolved.

===========================================================
Values
===========================================================

Syntax:
  value:
    <Value> value-Array
    <Value> value-Assoc
    <Value> value-Empty
    <Value> value-Funct
    <Value> value-Point
    <Value> value-StrEn
    <Value> value-Tuple
    <Value> value-Union

-----------------------------------------------------------
Array
-----------------------------------------------------------

Syntax:
  value-Array:
    type-Array ( expression-list(opt) )

-----------------------------------------------------------
Assoc
-----------------------------------------------------------

Syntax:
  value-Assoc:
    type-Assoc ( expression-list(opt) )

-----------------------------------------------------------
Empty
-----------------------------------------------------------

Syntax:
  value-Empty:
    type-Empty ( )

-----------------------------------------------------------
Funct
-----------------------------------------------------------

Syntax:
  value-Funct:
    type-Funct ( expression )

-----------------------------------------------------------
Point
-----------------------------------------------------------

Syntax:
  value-Point:
    type-Point ( expression , address-specifier string )

-----------------------------------------------------------
StrEn
-----------------------------------------------------------

Syntax:
  value-StrEn:
    type-StrEn ( expression )

-----------------------------------------------------------
Tuple
-----------------------------------------------------------

Syntax:
  value-Tuple:
    type-Tuple ( expression-list(opt) )

-----------------------------------------------------------
Union
-----------------------------------------------------------

Syntax:
  value-Union:
    type-Union ( expression )

===============================================================================
Specifiers
===============================================================================

Syntax:
  address-specifier:
    <Cpy>
    <Far>
    <GblArr>
    <GblArs>
    <GblReg>
    <Gen>
    <Lit>
    <Loc>
    <LocArs>
    <LocReg>
    <MapArr>
    <MapArs>
    <MapReg>
    <Nul>
    <Stk>
    <StrArr>
    <StrArs>
    <Vaa>
    <WldArr>
    <WldArs>
    <WldReg>

  call-type-specifier:
    <Action>
    <AsmFunc>
    <LangACS>
    <LangASM>
    <LangAXX>
    <LangC>
    <LangCXX>
    <LangDS>
    <Native>
    <Script>
    <ScriptI>
    <ScriptS>
    <Special>
    <StdCall>
    <StkCall>

  linkage-specifier:
    <ExtACS>
    <ExtASM>
    <ExtC>
    <ExtCXX>
    <ExtDS>
    <IntC>
    <IntCXX>

  script-type-specifier:
    <None>
    <BlueReturn>
    <Death>
    <Disconnect>
    <Enter>
    <Event>
    <Lightning>
    <Open>
    <Pickup>
    <RedReturn>
    <Respawn>
    <Return>
    <Unloading>
    <WhiteReturn>

===============================================================================
Grammar
===============================================================================

  assembly-unit:
    declaration(opt) assembly-unit(opt)

  declaration:
    function-declaration
    glyph-declaration
    import-declaration
    macro-declaration
    object-declaration
    space-declaration
    strent-declaration

  function-declaration:
    <Function> string function-argument-list(opt) new-line

  function-argument-list:
    function-argument function-argument-list(opt)

  function-argument:
    <alloc> = expression
    <block> new-line { statement-list(opt) }
    <ctype> = call-type-specifier
    <defin> = expression
    <label> = string
    <linka> = linkage-specifier
    <localArr> [ expression ] = expression
    <localArs> = expression
    <localReg> = expression
    <param> = expression
    <retrn> = expression
    <sflagClS> = expression
    <sflagNet> = expression
    <stype> = script-type-specifier
    <valueInt> = expression
    <valueStr> = string

  glyph-declaration:
    <Glyph> string glyph-argument-list(opt) new-line

  glyph-argument-list:
    glyph-argument glyph-argument-list(opt)

  glyph-argument:
    <type> = type
    <value> = expression

  import-declaration:
    <Import> string new-line

  macro-declaration:
    <Macro> identifier new-line(opt) { statement-list(opt) }

  identifier:
    non-digit
    identifier non-digit
    identifier digit

  non-digit: one of
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    _

  digit: one of
    0 1 2 3 4 5 6 7 8 9

  object-declaration:
    <Object> string object-argument-list(opt) new-line

  object-argument-list:
    object-argument object-argument-list(opt)

  object-argument:
    <alias> = expression
    <alloc> = expression
    <defin> = expression
    <initi> = expression
    <linka> = linkage-specifier
    <space> = address-specifier string
    <value> = expression
    <words> = expression

  space-declaration:
    <Space> address-specifier string space-argument-list(opt) new-line

  space-argument-list:
    space-argument space-argument-list(opt)

  space-argument:
    <alloc> = expression
    <defin> = expression
    <linka> = linkage-specifier
    <value> = expression
    <words> = expression

  strent-declaration:
    <StrEnt> string strent-argument-list(opt) new-line

  strent-argument-list:
    strent-argument strent-argument-list(opt)

  strent-argument:
    <alias> = expression
    <alloc> = expression
    <defin> = expression
    <valueInt> = expression
    <valueStr> = string

  statement-list:
    statement statement-list(opt)

  statement:
    statement-label-list(opt) statement-name expression argument-list(opt)
      new-line
    statement-label-list(opt) ! identifier argument-list(opt) new-line

  statement-label-list:
    string statement-label-list(opt)

  statement-name:
    <Nop>
    <AddF_W>
    <AddI_W>
    <AddU_W>
    <AndU_W>
    <Call>
    <Casm>
    <CmpF_EQ_W>
    <CmpF_GE_W>
    <CmpF_GT_W>
    <CmpF_LE_W>
    <CmpF_LT_W>
    <CmpF_NE_W>
    <CmpI_EQ_W>
    <CmpI_GE_W>
    <CmpI_GT_W>
    <CmpI_LE_W>
    <CmpI_LT_W>
    <CmpI_NE_W>
    <CmpU_EQ_W>
    <CmpU_GE_W>
    <CmpU_GT_W>
    <CmpU_LE_W>
    <CmpU_LT_W>
    <CmpU_NE_W>
    <Cnat>
    <Copy_W>
    <Cscr_IA>
    <Cscr_IS>
    <Cscr_SA>
    <Cscr_SS>
    <Cspe>
    <DivF_W>
    <DivI_W>
    <DivX_W>
    <InvU_W>
    <Jcnd_Nil>
    <Jcnd_Tru>
    <Jump>
    <ModI_W>
    <Move_W>
    <MulF_W>
    <MulI_W>
    <MulX_W>
    <NegF_W>
    <NegI_W>
    <NotU_W>
    <OrIU_W>
    <OrXU_W>
    <Plsa>
    <Plsf>
    <Pltn>
    <Retn>
    <ShLF_W>
    <ShLU_W>
    <ShRF_W>
    <ShRI_W>
    <ShRU_W>
    <SubF_W>
    <SubI_W>
    <SubU_W>
    <Swap_W>

  argument-list:
    , argument argument-list(opt)

  argument:
    <Aut> ( argument argument-offset(opt) )
    <Cpy> ( expression(opt) )
    <Far> ( argument argument-offset(opt) )
    <GblArr> ( argument , argument argument-offset(opt) )
    <GblArs> ( argument argument-offset(opt) )
    <GblReg> ( argument argument-offset(opt) )
    <Gen> ( argument argument-offset(opt) )
    <Lit> ( expression argument-offset(opt) )
    <LocReg> ( argument argument-offset(opt) )
    <MapArr> ( argument , argument argument-offset(opt) )
    <MapArs> ( argument argument-offset(opt) )
    <MapReg> ( argument argument-offset(opt) )
    <Nul> ( )
    <Sta> ( argument argument-offset(opt) )
    <Stk> ( )
    <StrArr> ( argument , argument argument-offset(opt) )
    <StrArs> ( argument argument-offset(opt) )
    <Vaa> ( argument argument-offset(opt) )
    <WldArr> ( argument , argument argument-offset(opt) )
    <WldArs> ( argument argument-offset(opt) )
    <WldReg> ( argument argument-offset(opt) )

  argument-offset:
    , expression

  expression:
    aggregate
    aggregate-string
    number
    string
    value
    <Add> ( expression , expression )
    <AddPtrRaw> ( expression , expression )
    <BitAnd> ( expression , expression )
    <BitOrI> ( expression , expression )
    <BitOrX> ( expression , expression )
    <CmpEQ> ( expression , expression )
    <CmpGE> ( expression , expression )
    <CmpGT> ( expression , expression )
    <CmpLE> ( expression , expression )
    <CmpLT> ( expression , expression )
    <CmpNE> ( expression , expression )
    <Cnd> ( expression , expression , expression )
    <Cst> ( type , expression )
    <Div> ( expression , expression )
    <Inv> ( expression )
    <LogAnd> ( expression , expression )
    <LogOrI> ( expression , expression )
    <LogOrX> ( expression , expression )
    <Mod> ( expression , expression )
    <Mul> ( expression , expression )
    <Neg> ( expression )
    <Not> ( expression )
    <ShL> ( expression , expression )
    <ShR> ( expression , expression )
    <Sub> ( expression , expression )
    -- expression
    ~ expression
    ! expression
    * expression expression
    / expression expression
    % expression expression
    + expression expression
    - expression expression
    << expression expression
    >> expression expression
    < expression expression
    > expression expression
    <= expression expression
    >= expression expression
    == expression expression
    != expression expression
    & expression expression
    ^ expression expression
    | expression expression
    && expression expression
    ^^ expression expression
    || expression expression
    ? expression expression expression

  type:
    type-Array
    type-Assoc
    type-Empty
    type-Fixed
    type-Float
    type-Funct
    type-Point
    type-StrEn
    type-Tuple
    type-Union

  type-Array:
    <Array> ( type , expression )

  type-Assoc:
    <Assoc> ( type-assoc-list(opt) )

  type-Empty:
    <Empty> ( )

  type-Fixed:
    <Fixed> ( expression , expression , expression , expression )

  type-Float:
    <Float> ( expression , expression , expression , expression )

  type-Funct:
    <Funct> ( call-type-specifier )

  type-Point:
    <Point> ( address-specifier string , expression , expression )

  type-StrEn:
    <StrEn> ( )

  type-Tuple:
    <Tuple> ( type-list(opt) )

  type-Union:
    <Union> ( type-list(opt) )

  type-assoc-list:
    type-assoc
    type-assoc , type-assoc-list

  type-assoc:
    type string expression

  type-list:
    type
    type , type-list

  aggregate:
    <Tuple> ( expression-list(opt) )
    { expression-list(opt) }
    [ expression-list(opt) ]

  expression-list:
    expression
    expression , expression-list

  aggregate-string:
    <string> type-Fixed(opt) string

  number:
    decimal-number number-suffix(opt)
    hexadecimal-number number-suffix(opt)
    octal-number number-suffix(opt)

  decimal-number:
    decimal-base decimal-fractional(opt) decimal-exponent(opt)
    decimal-integral(opt) decimal-fractional decimal-exponent(opt)

  hexadecimal-number:
    hexadecimal-base hexadecimal-fractional(opt) hexadecimal-exponent(opt)

  octal-number:
    octal-base decimal-exponent(opt)

  number-suffix:
    _ number-suffix-f(opt) number-suffix-s(opt) decimal-integral
      decimal-fractional number-suffix-s(opt)

  number-suffix-f: one of
    <F> <f>

  number-suffix-s: one of
    <S> <s>

  decimal-base:
    decimal-prefix decimal-integral(opt)

  decimal-fractional:
    . decimal-integral(opt)

  decimal-exponent:
    <E> sign(opt) decimal-integral
    <e> sign(opt) decimal-integral
    hexadecimal-exponent

  decimal-integral:
    digit decimal-integral(opt)

  decimal-prefix: one of
    1 2 3 4 5 6 7 8 9

  hexadecimal-base:
    hexadecimal-prefix hexadecimal-integral(opt)

  hexadecimal-fractional:
    . hexadecimal-integral(opt)

  hexadecimal-exponent:
    <P> sign(opt) decimal-integral
    <p> sign(opt) decimal-integral

  hexadecimal-integral:
    hexadecimal-digit hexadecimal-integral(opt)

  hexadecimal-digit: one of
    0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

  octal-base:
    octal-prefix octal-integral(opt)

  octal-prefix:
    0

  octal-integral:
    octal-digit octal-integral(opt)

  octal-digit: one of
    0 1 2 3 4 5 6 7

  sign: one of
    + -

  string:
    " char-sequence(opt) "

  char-sequence:
    char char-sequence(opt)

  char:
    any character except double-quote, backslash, or new-line
    escape-sequence

  escape-sequence:
    hexadecimal-escape-sequence
    octal-escape-sequence
    simple-escape-sequence

  hexadecimal-escape-sequence:
    \x hexadecimal-digit
    hexadecimal-escape-sequence hexadecimal-digit

  octal-escape-sequence:
    \ octal-digit
    \ octal-digit octal-digit
    \ octal-digit octal-digit octal-digit

  simple-escape-sequence: one of
    \' \" \? \\ \a \b \f \n \r \t \v

  value:
    <Value> value-Array
    <Value> value-Assoc
    <Value> value-Empty
    <Value> value-Funct
    <Value> value-Point
    <Value> value-StrEn
    <Value> value-Tuple
    <Value> value-Union

  value-Array:
    type-Array ( expression-list(opt) )

  value-Assoc:
    type-Assoc ( expression-list(opt) )

  value-Empty:
    type-Empty ( )

  value-Funct:
    type-Funct ( expression )

  value-Point:
    type-Point ( expression , address-specifier string )

  value-StrEn:
    type-StrEn ( expression )

  value-Tuple:
    type-Tuple ( expression-list(opt) )

  value-Union:
    type-Union ( expression )

  address-specifier:
    <Cpy>
    <Far>
    <GblArr>
    <GblArs>
    <GblReg>
    <Gen>
    <Lit>
    <Loc>
    <LocArs>
    <LocReg>
    <MapArr>
    <MapArs>
    <MapReg>
    <Nul>
    <Stk>
    <StrArr>
    <StrArs>
    <Vaa>
    <WldArr>
    <WldArs>
    <WldReg>

  call-type-specifier:
    <Action>
    <AsmFunc>
    <LangACS>
    <LangASM>
    <LangAXX>
    <LangC>
    <LangCXX>
    <LangDS>
    <Native>
    <Script>
    <ScriptI>
    <ScriptS>
    <Special>
    <StdCall>
    <StkCall>

  linkage-specifier:
    <ExtACS>
    <ExtASM>
    <ExtC>
    <ExtCXX>
    <ExtDS>
    <IntC>
    <IntCXX>

  script-type-specifier:
    <None>
    <BlueReturn>
    <Death>
    <Disconnect>
    <Enter>
    <Event>
    <Lightning>
    <Open>
    <Pickup>
    <RedReturn>
    <Respawn>
    <Return>
    <Unloading>
    <WhiteReturn>

###############################################################################
EOF
###############################################################################

